import { ChatPromptTemplate } from '@langchain/core/prompts'
import { ChatOpenAI } from '@langchain/openai'
import type GraphState from './state'

const model = new ChatOpenAI({
  model: 'gpt-4o',
  openAIApiKey: Bun.env.OPENAI_API_KEY,
  temperature: 0.7,
})

export const twitterPersonalityGenerater = async (
  state: typeof GraphState.State,
) => {
  const promptText = `Given that a user with twitter handle {handle} has made following tweets in the past:

        {tweets}

        Please use this information to create a twitter personality description for this user.  It should encapsulate the 
        user's style, tone, areas of interest and general vibe.
        The personlity description should be such that it could be used later to create new tweets, matching the user's personality, on behalf of this user later

        Return the personlity description for this user`

  const prompt = ChatPromptTemplate.fromTemplate(promptText)

  const result = await prompt.pipe(model).invoke({
    handle: state.handle,
    tweets: state.tweets,
  })
  return { twitter_personality: result.content }
}

export const tweetTextGenerater = async (state: typeof GraphState.State) => {
  let prevGeneratedTweetsPrompt1 = ''
  let prevGeneratedTweetsPrompt2 = ''
  if (state.generated_tweets?.length > 0) {
    prevGeneratedTweetsPrompt1 = `Following are the tweets previously generated by you for this user that the user is not fully satisfied with:

          ${state.generated_tweets}`

    prevGeneratedTweetsPrompt2 =
      '4. should not be same as any of the previously generated tweets.'
  }

  const promptText = `You are a marketing professional that comes up with clean, funny and intellectual tweet texts to help promote Payman on twitter.
        Payman Company Information: Payman is an AI company that makes it possible for AI to participate in the human economy. 
        It enables AIs to have access to funds in order to make payments to people and businesses. 
        It let developers plug into simple, clean APIs to provide their AI Agents with secure, easy payment capabilities.
        
        For a user with twitter handle {handle}, following is the user's twitter personality based on the existing tweets made by the user:

        {twitter_personality}

        {prev_generated_tweets_prompt1}

        Use this personality and the above Payman company information to create a tweet text for this user, using their own style and personality.
        The tweet text: 
        1. should promote Payman
        2. should be clean, funny and playful
        3. should not be more than {word_count} characters
        4. it should contain at most one hashtag
        {prev_generated_tweets_prompt2}

        Return only the newly created tweet text, no preamble or additional information.`

  const prompt = ChatPromptTemplate.fromTemplate(promptText)

  const result = await prompt.pipe(model).invoke({
    handle: state.handle,
    twitter_personality: state.twitter_personality,
    word_count: 280,
    prev_generated_tweets_prompt1: prevGeneratedTweetsPrompt1,
    prev_generated_tweets_prompt2: prevGeneratedTweetsPrompt2,
  })

  return { generated_tweets: [result] }
}

export const urlExtracter = async (state: typeof GraphState.State) => {
  const promptText = `Given following text:

        {text}

        Please parse this text and identify all urls belonging to x.com website.

        Include all such urls in the response string separated by semi-colon
        Do not include any other markdown or preamble or additional information.`

  const prompt = ChatPromptTemplate.fromTemplate(promptText)

  const result = await prompt.pipe(model).invoke({
    text: state.submission_details,
  })
  const urls = (result.content as string).split(';')
  return { submitted_tweet_urls: urls }
}

export const twitterIdExtracter = async (state: typeof GraphState.State) => {
  const promptText = `Given following text:

        {text}

        Please parse this text and identify all urls belonging to x.com website.
        For each such url, tokenize the url using '/' as the delimiter and extract the last token as twitterId.

        Remove duplicates from all such twitterIds and include the unique ones in the response string separated by semi-colon.
        Do not include any other markdown or preamble or additional information.`

  const prompt = ChatPromptTemplate.fromTemplate(promptText)

  const result = await prompt.pipe(model).invoke({
    text: state.submission_details,
  })
  const tweetIds = (result.content as string).split(';')
  return { submitted_tweet_ids: tweetIds }
}
